<!DOCTYPE html>
<html lang="en">
<head>
    <title>Creating an iPhone Application</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Getting Started">
    <script>String.prototype.cleanUpURL=function(){var c,b="",a=this;if(this.match("#")){b="#"+this.split("#")[1];a=this.split("#")[0]}a=a.replace(/\/\.\/|([^:])\/\//g,"$1/");if(a==="./"){return""+b}while(a!==c){c=a;a=a.replace(/[\/][^\/]+\/+\.\.\//,"/")}a=a.replace(/^.[^\/]+\/+\.\.\//,"");return a+b};(function(){var a="../../../";var c=window.location.pathname;var b=(c.slice(0,c.lastIndexOf("/"))+"/"+a).cleanUpURL();if(top.location.href==window.location.href){if("createTouch" in document){if(document.getElementById("book-resource-type").content!=="Standalone"){switch(navigator.platform){case"iPad":window.location.replace(a+"ipad/#"+c.replace(b,"")+window.location.hash);break;case"iPhone":break}}}else{window.location.replace(a+(window.location.protocol=="file:"?"index.html":"")+"#"+c.replace(b,"")+window.location.hash)}}})();</script>
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40007595">
    <meta id="date" name="date" content="2009-10-12">
    <meta id="description" name="description" content="Provides a guided tour of an iPhone application.">
    <meta id="book-title" name="book-title" content="Creating an iPhone Application">
    <meta id="book-root" name="book-root" content="./">
    <meta id="book-json" name="book-json" content="book.json">
    <meta id="book-assignments" name="book-assignments" content="{Type/Getting Started}, {Topic/General}">
    
    
    <meta id="generator" name="generator" content="Gutenberg 26977M">
    <meta name='numbat' content='aa879094b666337fdcde744b62fbff30'>
    <meta id="copyright" name="copyright" content="Copyright 2011 Apple Inc. All Rights Reserved.">
    <meta name = "viewport" content = "width = device-width" >
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Creating an iPhone Application">
    <meta id="resources-uri" name="resources-uri" content="../../../Resources/565">
    <link id="book-index-page" rel="Start" title="Creating an iPhone Application" type="text/html" href="index.html">
    <link id="next-page" rel="Next" type="text/html" href="">
    <link id="previous-page" rel="Prev" type="text/html" href="">
    <link rel="stylesheet" type="text/css" href="../../../Resources/565/CSS/ac_media.css" charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../../../Resources/565/CSS/devpubs.css" charset="utf-8">
    <link rel="stylesheet" type="text/css" href="../../../Resources/565/CSS/docs.css" charset="utf-8">
    <!--[if IE]><link rel="stylesheet" type="text/css" href="../../../Resources/565/CSS/ie.css"><![endif]-->
    <link rel='stylesheet' type='text/css' href='../../../Resources/565/CSS/gettingstarted.css' />
<link rel="stylesheet" type="text/css" href="../../../Resources/565/CSS/xcode4.css" charset="utf-8">
</head>    
<body><a name="//apple_ref/doc/uid/TP40007595" title="Creating an iPhone Application"></a>
    <article id="contents" tabindex="0" role="main">
        <!-- CONTENTS -->
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/TP40007595-CH1-SW1" title="Creating an iPhone Application"></a><h2>Creating an iPhone Application</h2><p>At a high level, the process for creating an iPhone application is similar to that for creating a Mac OS X application. Both use the same tools and many of the same basic libraries. Despite the similarities, there are also significant differences. An iPhone is not a desktop computer; it has a different purpose and requires a very different design approach. That approach needs to take advantage of the strengths of iOS and forego features that might be irrelevant or impractical in a mobile environment. The smaller size of the iPhone and iPod touch screens also means that your application’s user interface should be well organized and always focused on the information the user needs most.</p><p>iOS lets users interact with iPhone and iPod touch devices in ways that you cannot interact with desktop applications. The Multi-Touch interface reports on each separate finger that touches the screen and making it possible to handle multifinger gestures and other complex input easily. In addition, built-in hardware features such as the accelerometers, although present in some desktop systems, are used more extensively in iOS to track the screen’s current orientation and adjust your content accordingly. Understanding how you can use these features in your applications will help you focus on a design that is right for your users.</p><p>The best way to understand the design of an iPhone application is to look at an example. This article takes you on a tour of the <span class="content_text"><a href="http://developer.apple.com/library/ios/samplecode/MoveMe/index.html" class="browserLink" >MoveMe</a></span> sample application. This sample demonstrates many of the typical behaviors of an iPhone application, including:</p><ul><li><p>Initializing the application</p></li><li><p>Displaying a window</p></li><li><p>Drawing custom content</p></li><li><p>Handling touch events</p></li><li><p>Performing animations</p></li></ul><p><span class="content_text">Figure 1</span> shows the interface for this application. Touching the Welcome button triggers an animation that causes the button to pulse and center itself under your finger. As you drag your finger around the screen, the button follows your finger. Lift your finger from the screen and, using another animation, the button snaps back to its original location. Double-tapping anywhere outside the button changes the language of the button’s greeting.</p><br><a name="//apple_ref/doc/uid/TP40007595-CH1-SW2" title="Figure 1The MoveMe application window"></a><figcaption><strong class="caption_number">Figure 1</strong>&nbsp;&nbsp;The MoveMe application window</figcaption><img src="Art/MoveMe.jpg" alt="The MoveMe application" width="309" height="594"><br><p>Before reading the other sections of this article, you should download the sample (<span class="content_text"><a href="http://developer.apple.com/library/ios/samplecode/MoveMe/index.html" class="browserLink" >MoveMe</a></span>) so that you can follow along directly in the source code. You should also have already read the following orientation pages in the iOS Dev Center to get a basic understanding of iOS and the tools and language you use for development: </p><ul><li><p><span class="content_text"><a href="../URL_iPhone_OS_Overview/_index.html#//apple_ref/doc/uid/TP40007592" target="_self">iOS Overview</a></span></p></li><li><p><span class="content_text"><a href="../URL_Tools_for_iPhone_OS_Development/_index.html#//apple_ref/doc/uid/TP40007593" target="_self">Tools for iOS Development</a></span></p></li></ul><p>If you are not familiar with the <span class="pediaLink" data-header="Objective-C" data-contents="Objective-C defines a small but powerful set of extensions to the ANSI  C programming language that enables sophisticated object-oriented programming. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/ObjectiveC.html#//apple_ref/doc/uid/TP40008195-CH43" target="_self">Objective-C</a></span> programming language, you should also have read <span class="content_text"><a href="../Learning_Objective-C_A_Primer/_index.html#//apple_ref/doc/uid/TP40007594" target="_self">Learning Objective-C: A Primer</a></span> to familiarize yourself with the basic syntax of Objective-C.</p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW17" title="Examining the MoveMe Sample Project"></a><h3>Examining the MoveMe Sample Project</h3><p>Downloading the <span class="content_text"><a href="http://developer.apple.com/library/ios/samplecode/MoveMe/index.html" class="browserLink" >MoveMe</a></span> sample provides you with the source code and support files needed to build and run the application. You manage projects for iOS using the Xcode application (located in <code>/Developer/Applications</code> by default). Each Xcode project window combines a workspace for gathering your code and resource files, build rules for compiling your source and assembling your application, and tools for editing and debugging your code.</p><p> <span class="content_text">Figure 2</span> shows the Xcode project window for the MoveMe application. To open this project, copy it to your local hard drive and double-click the <code>MoveMe.xcodeproj</code> file to open it. (You can also open the project from within Xcode by selecting File > Open and choosing the file.) The project includes several Objective-C source files (denoted by the <code>.m</code> extension), some image files and other resources, and a predefined target (<code>MoveMe</code>) for building the application bundle. </p><br><a name="//apple_ref/doc/uid/TP40007595-CH1-SW3" title="Figure 2The MoveMe project window"></a><figcaption><strong class="caption_number">Figure 2</strong>&nbsp;&nbsp;The MoveMe project window</figcaption><img src="Art/moveme_project.jpg" class="wide-image" alt="The MoveMe project window" width="797" height="544"><img src="Art/moveme_project.jpg" class="ipad-scaled-image" alt="The MoveMe project window" width="670" height="457"><br><p>In iOS, the ultimate target of your Xcode project is an application <span class="pediaLink" data-header="Bundle" data-contents="A bundle is a directory in the file system that groups executable code and related resources such as images and sounds together in one place. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/Bundle.html#//apple_ref/doc/uid/TP40008195-CH4" target="_self">bundle</a></span>, which is a special type of directory that houses your application’s binary executable and supporting resource files. Bundles in iOS have a relatively flat directory structure, with most files residing at the top level of the bundle directory. However, a bundle may also contain subdirectories to store localized versions of strings and other language-specific resource files. You do not need to know the exact structure of the application bundle for the purposes of this article, but you can find that information in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BuildTimeConfiguration/BuildTimeConfiguration.html#//apple_ref/doc/uid/TP40007072-CH7" target="_self">“Build-Time Configuration Details”</a></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span> if you are interested in it. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW7" title="Building the MoveMe Application"></a><h4>Building the MoveMe Application</h4><p>To build the MoveMe application and run it in the simulator, do the following:</p><ol class="ol"><li><p>Open the <code>MoveMe.xcodeproj</code> file in Xcode.</p></li><li><p>In the project toolbar, make sure the simulator option is selected in the Active SDK menu. (If the Active SDK menu does not appear in the toolbar, choose Project > Set Active SDK > Simulator.)</p></li><li><p>Select Build > Build and Go (Run) from the menu, or simply click the Build and Go button in the toolbar.</p></li></ol><p>When the application finishes building, Xcode loads it into the iOS Simulator and launches it. Using your mouse, you can click the Welcome button and drag it around the screen to see the application’s behavior. If you have a device configured for development, you can also build your application and run it on that device. For information about how to configure devices for development and load applications, see <span class="content_text"><a href="../../../documentation/Xcode/Conceptual/iphone_development/000-Introduction/introduction.html#//apple_ref/doc/uid/TP40007959" target="_self">iOS Development Guide</a></span>. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW11" title="A Word About Memory Management"></a><h4>A Word About Memory Management</h4><p>iOS is primarily an object-oriented system, so most of the memory you allocate is in the form of Objective-C objects. iOS uses a <span class="pediaLink" data-header="Memory management" data-contents="Memory management is the programming discipline of managing the life cycles of objects and freeing them when they are no longer needed. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/MemoryManagement.html#//apple_ref/doc/uid/TP40008195-CH27" target="_self">reference counting scheme</a></span> to know when it is safe to free up the memory occupied by an object. When you first create an object, it starts off with a reference count of 1. Clients receiving that object can opt to retain it, thereby incrementing its reference count by 1. If a client retains an object, the client must also release that object when it is no longer needed. Releasing an object decrements its reference count by 1. When an object’s reference count equals 0, the system automatically reclaims the memory for the object. </p><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40007595-CH1-SW20" title="Note"></a><p><strong>Note:</strong>&nbsp;iOS does not support memory management using the garbage collection feature that is in Mac OS X v10.5 and later. </p><p></p></aside></div><p>If you want to allocate generic blocks of memory—that is, memory not associated with an object—you can do so using the standard <code>malloc</code> library of calls. As is the case with any memory you allocate using <code>malloc</code>, you are responsible for releasing that memory when you are done with it by calling the <code>free</code> function. The system does not release malloc-based blocks for you.</p><p>Regardless of how you allocate memory, managing your overall memory usage is important. Although iOS has a virtual memory system, it does not use a swap file. This means that code pages can be flushed as needed but your application’s data must all fit into memory at the same time. The system monitors the overall amount of free memory and does what it can to give your application the memory it needs. If memory usage becomes too critical though, the system may terminate your application. However, this option is used only as a last resort, to ensure that the system has enough memory to perform critical operations such as receiving phone calls.</p><p>For more information about how to allocate objects in iOS, see <span class="content_text"><a href="../../../documentation/Cocoa/Conceptual/CocoaFundamentals/Introduction/Introduction.html#//apple_ref/doc/uid/TP40002974" target="_self">Cocoa Fundamentals Guide</a></span>. For information and tips on how to improve your application’s memory usage, see <span class="content_text"><!--a target="_self" -->“Using Memory Efficiently”<!--/a--></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>.</p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW24" title="Initializing the MoveMe Application"></a><h3>Initializing the MoveMe Application</h3><p>As is true for every C-based application, the initial entry point for every iPhone application is a function called <code>main</code>. The good news is that, when you create a new project using the iPhone templates in Xcode, you do not have to write this function yourself. The project templates include a version of this function with all the code needed to start your application.</p><p><span class="content_text">Listing 1</span> shows the <code>main</code> function for the MoveMe application. The main function is located in that project’s <code>main.m</code> file. Every application you create will have a <code>main</code> function that is almost identical to this one. This function performs two key tasks. First, it creates the application’s top-level autorelease pool used by the memory management reference counting system. Second, it calls the <code>UIApplicationMain</code> function to create the MoveMe application’s key objects, initialize those objects, and start the event-processing loop. The application does not return from this function until it quits. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW9" title="Listing 1Using the provided main function"></a><p class="codesample clear"><strong class="caption_number">Listing 1</strong>&nbsp;&nbsp;Using the provided <code>main</code> function</p><div class="codesample"><table cellspacing="0" cellpadding="3" width="100%" bgcolor="#F1F5F9" style="border: 1px solid #C9D1D7;"><tr><td scope="row"><pre>int main(int argc, char *argv[])<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    int retVal = UIApplicationMain(argc, argv, nil, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>    [pool release];<span></span></pre></td></tr><tr><td scope="row"><pre>    return retVal;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40007595-CH1-SW33" title="Defining the Application Delegate"></a><h3>Defining the Application Delegate</h3><p>One of the most important architectural details of your project is defining the application <span class="pediaLink" data-header="Delegation" data-contents="Delegation is a simple and powerful pattern in which one object in a program acts on behalf of, or in coordination with, another object. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/Delegation.html#//apple_ref/doc/uid/TP40008195-CH14" target="_self">delegate</a></span> object, which is instantiated from a class you provide in your project. The application delegate class in MoveMe project declares its interface in <code>MoveMeAppDelegate.h</code> and defines its implementation in <code>MoveMeAppDelegate.m</code>. Once you have added these files to the project, you can use Interface Builder to designate an instance of the class as the application delegate. Interface Builder is a visual tool that you use to create and arrange views in a window, set up view hierarchies, configure each view’s options, and establish relationships between the views and the other objects of your application. Because it is a visual tool, you perform all of these tasks by dragging components around a window surface. The result is an interactive version of your interface that you can see immediately and change in seconds. Interface Builder saves your user interface in a file known as a <span class="pediaLink" data-header="Nib file" data-contents="A nib file is a special type of resource file that you use to store the user interfaces of iOS and Mac OS X applications. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/NibFile.html#//apple_ref/doc/uid/TP40008195-CH34" target="_self">nib file</a></span>, which is an archive of your application’s object graph.</p><p>To launch Interface Builder and see how the application delegate object’s role is defined, double-click the <code>MainWindow.xib</code> file (under MoveMe > Resources) in the Groups &amp; Files pane of the Xcode project window. <code>MainWindow.xib</code> is the nib file that contains your application’s window and defines the relationships among several important objects in your application, including the application delegate. To see how the application delegate relationship is established, click the File’s Owner icon in the nib file document window (titled “MainWindow.xib”), show the Inspector window (choose Tools > Inspector), and click the Inspector window’s Application Connections tab. As shown in <span class="content_text">Figure 3</span>, the Inspector shows that the File’s Owner object (which represents the application in the nib file) has a delegate outlet connected to the <code>MoveMeAppDelegate</code> object.</p><br><a name="//apple_ref/doc/uid/TP40007595-CH1-SW25" title="Figure 3The application delegate"></a><figcaption><strong class="caption_number">Figure 3</strong>&nbsp;&nbsp;The application delegate</figcaption><img src="Art/appdelegate.jpg" class="wide-image" alt="" width="702" height="334"><img src="Art/appdelegate.jpg" class="ipad-scaled-image" alt="" width="670" height="318"><br><p>The application delegate object works in tandem with the standard <code>UIApplication</code> object to respond to changing conditions in the application. The application object does most of the heavy lifting, but the delegate is responsible for several key behaviors, including the following:</p><ul><li><p>Setting up the application’s window and initial user interface</p></li><li><p>Performing any additional initialization tasks needed for your custom data engine</p></li><li><p>Opening content associated with the application’s custom URL schemes</p></li><li><p>Responding to changes in the orientation of the device </p></li><li><p>Handling low-memory warnings</p></li><li><p>Handling system requests to quit the application</p></li></ul><p>At launch time, the most immediate concern for the delegate object is to set up and present the application window to the user, which is described in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007595-CH1-SW10">“Creating the Application Window”</a></span>. The delegate should also perform any tasks needed to prepare your application for immediate use, such as restoring the application to a previous state or creating any required objects. When the application quits, the delegate needs to perform an orderly shutdown of the application and save any state information needed for the next launch cycle. </p><p>For more information about the fundamental architecture and life cycle of an iPhone application, see <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BuildTimeConfiguration/BuildTimeConfiguration.html#//apple_ref/doc/uid/TP40007072-CH7-SW2" target="_self">“Core Application Architecture”</a></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW10" title="Creating the Application Window"></a><h3>Creating the Application Window</h3><p>Every application is responsible for creating a window that spans the entire screen and for filling that window with content. Graphical applications running in iOS do not run side-by-side with other applications. In fact, other than the kernel and a few low-level system daemons, your application is the only thing running after it is launched. What’s more, your application should never need more than one window—an instance of the <code>UIWindow</code> class. In situations where you need to change your user interface, you change the views displayed by your window. </p><p>Windows provide the drawing surface for your user interface, but view objects provide the actual content. A view object is an instance of the <code>UIView</code> class that draws some content and responds to interactions with that content. iOS defines standard views to represent things such as tables, buttons, text fields, and other types of interactive controls. You can add any of these views to your window, or you can define custom views by subclassing <code>UIView</code> and implementing some custom drawing and event-handling code. The MoveMe application defines two such views—represented by the <code>MoveMeView</code> and <code>PlacardView</code> classes—to display the application’s interface and handle user interactions. </p><p>At launch time, the goal is to create the application window and display some initial content as quickly as possible. The window is <span class="pediaLink" data-header="Archiving" data-contents="Archiving is the process of converting a group of related objects to a form that can be stored or transferred between applications. "><a href="../../../documentation/General/Conceptual/DevPedia-CocoaCore/Archiving.html#//apple_ref/doc/uid/TP40008195-CH1" target="_self">unarchived</a></span> from the <code>MainWindow.xib</code> nib file. When the application reaches a state where it is launched and ready to start processing events, the <code>UIApplication</code> object sends the delegate an <code>applicationDidFinishLaunching:</code> message. This message is the delegate’s cue to put content in its window and perform any other initialization the application might require. </p><p>In the MoveMe application, the delegate’s <code>applicationDidFinishLaunching:</code> method does the following:</p><ol class="ol"><li><p>It creates a view controller object whose job is to manage the content view of the window.</p></li><li><p>It initializes the view controller with an instance of the <code>MoveMeView</code> class, which is stored in the <code>MoveMeView.xib</code> nib file, to act as the background view and fill the entire window frame.</p></li><li><p>It adds the controller’s view as a subview of the window.</p></li><li><p>It shows the window.</p></li></ol><p><span class="content_text">Listing 2</span> shows the <code>applicationDidFinishLaunching:</code> method for the MoveMe application, which is defined in the application delegate’s implementation file, <code>MoveMeAppDelegate.m</code>. This method creates the main content view for the window and makes the window visible. Showing the window lets the system know that your application is ready to begin handling events. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW21" title="Listing 2Creating the content view"></a><p class="codesample clear"><strong class="caption_number">Listing 2</strong>&nbsp;&nbsp;Creating the content view</p><div class="codesample"><table cellspacing="0" cellpadding="3" width="100%" bgcolor="#F1F5F9" style="border: 1px solid #C9D1D7;"><tr><td scope="row"><pre>- (void)applicationDidFinishLaunching:(UIApplication *)application<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Set up the view controller<span></span></pre></td></tr><tr><td scope="row"><pre>    UIViewController *aViewController = [[UIViewController alloc]<span></span></pre></td></tr><tr><td scope="row"><pre>               initWithNibName:@"MoveMeView" bundle:[NSBundle mainBundle]];<span></span></pre></td></tr><tr><td scope="row"><pre>    self.viewController = aViewController;<span></span></pre></td></tr><tr><td scope="row"><pre>    [aViewController release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Add the view controller's view as a subview of the window<span></span></pre></td></tr><tr><td scope="row"><pre>    UIView *controllersView = [viewController view];<span></span></pre></td></tr><tr><td scope="row"><pre>    [window addSubview:controllersView];<span></span></pre></td></tr><tr><td scope="row"><pre>    [window makeKeyAndVisible];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40007595-CH1-SW4" title="Note"></a><p><strong>Note:</strong>&nbsp;You can use the <code>applicationDidFinishLaunching:</code> method to perform other tasks besides setting up your application user interface. Many applications use it to initialize required data structures, read any user preferences, or return the application to the state it was in when it last quit.</p><p></p></aside></div><p>Although the preceding code creates the window's background view and then shows the window, what you do not see in the preceding code is the creation of the <code>PlacardView</code> class that displays the Welcome button. That behavior is handled by the <code>setUpPlacardView</code> method of the <code>MoveMeView</code> class, which is called from the <code>initWithCoder:</code> method called when the <code>MoveMeView</code> object is unarchived from its nib file. The <code>setUpPlacardView</code> method is shown in <span class="content_text">Listing 3</span>. Part of the initialization of this view includes the creation of a <code>PlacardView</code> object. Because the <code>MoveMeView</code> class provides the background for the entire application, it adds the <code>PlacardView</code> object as a subview. The relationship between the two views not only causes the Welcome button to be displayed on top of the application’s background, it also allows the <code>MoveMeView</code> class to handle events that are targeted at the button.</p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW6" title="Listing 3Creating the placard view"></a><p class="codesample clear"><strong class="caption_number">Listing 3</strong>&nbsp;&nbsp;Creating the placard view</p><div class="codesample"><table cellspacing="0" cellpadding="3" width="100%" bgcolor="#F1F5F9" style="border: 1px solid #C9D1D7;"><tr><td scope="row"><pre>- (void)setUpPlacardView<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the placard view -- it calculates its own frame based on its image.<span></span></pre></td></tr><tr><td scope="row"><pre>    PlacardView *aPlacardView = [[PlacardView alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    self.placardView = aPlacardView;<span></span></pre></td></tr><tr><td scope="row"><pre>    [aPlacardView release];<span></span></pre></td></tr><tr><td scope="row"><pre>    placardView.center = self.center;<span></span></pre></td></tr><tr><td scope="row"><pre>    [self addSubview:placardView];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For detailed information about creating windows and views, see <span class="content_text"><!--a target="_self" -->“What Are Windows and Views?”<!--/a--></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW27" title="Drawing the Welcome Button"></a><h3>Drawing the Welcome Button</h3><p>You can use standard views provided by UIKit without modification to draw many types of simple content. For example, you can use the <code>UIImageView</code> class to display images and the <code>UILabel</code> class to display text strings. The <code>MoveMeView</code> class in the MoveMe application also takes advantage of a basic property of all <code>UIView</code> objects—specifically, the <code>backgroundColor</code> property—to fill the view with a solid color. This property can be set in code in the view object’s initialization method. In this case, the property is set when <code>MoveMeView</code> is created in the <code>MoveMeView.xib</code> nib file, using a color well in the Attributes tab of the Inspector window of Interface Builder. When you need to draw content dynamically, however, you must use the more advanced drawing features found in UIKit or you must use Quartz or OpenGL ES. </p><p>The <code>PlacardView</code> class in the MoveMe application draws the Welcome button and manages its location on the screen. Although the <code>PlacardView</code> class could draw its content using an embedded <code>UIImageView</code> and <code>UILabel</code> object, it instead draws the content explicitly, to demonstrate the overall process. As a result, this class implements a <code>drawRect:</code> method, which is where all custom drawing for a view takes place.</p><p>By the time a view’s <code>drawRect:</code> method is called, the drawing environment is configured and ready to go. All you have to do is specify the drawing commands to draw any custom content. In the <code>PlacardView</code> class, the content consists of a background image (stored in the <code>Placard.png</code> resource file) and a custom string, the text for which can change dynamically. To draw this content, the class takes the following steps:</p><ol class="ol"><li><p>Draw the background image at the view’s current origin. (Because the view is already sized to fit the image, this step provides the entire button background.)</p></li><li><p>Compute the position of the welcome string so that it is centered in the button. (Because the string size can change, the position needs to be computed each time based on the current string size.) </p></li><li><p>Set the drawing color to black. </p></li><li><p>Draw the string in black, and slightly offset.</p></li><li><p>Set the drawing color to white.</p></li><li><p>Draw the string again in white at its intended location. </p></li></ol><p><span class="content_text">Listing 4</span> shows the <code>drawRect:</code> method for the <code>PlacardView</code> class. The <code>placardImage</code> member variable contains a <code>UIImage</code> object with the background for the button and the <code>currentDisplayString</code> member variable is an <code>NSString</code> object containing the welcome string. After drawing the image, this method calculates the position of the string within the view. The size of the string is already known, having been calculated when the string was loaded and stored in the <code>textSize</code> member variable. The string is then drawn twice—once in black and once in white—using the <code>drawAtPoint:forWidth:withFont:fontSize:lineBreakMode:baselineAdjustment:</code> method of <code>NSString</code>. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW26" title="Listing 4Drawing the Welcome button"></a><p class="codesample clear"><strong class="caption_number">Listing 4</strong>&nbsp;&nbsp;Drawing the Welcome button</p><div class="codesample"><table cellspacing="0" cellpadding="3" width="100%" bgcolor="#F1F5F9" style="border: 1px solid #C9D1D7;"><tr><td scope="row"><pre>- (void)drawRect:(CGRect)rect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Draw the placard at 0, 0<span></span></pre></td></tr><tr><td scope="row"><pre>    [placardImage drawAtPoint:(CGPointMake(0.0, 0.0))];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*<span></span></pre></td></tr><tr><td scope="row"><pre>     Draw the current display string.<span></span></pre></td></tr><tr><td scope="row"><pre>     This could be done using a UILabel, but this serves to illustrate<span></span></pre></td></tr><tr><td scope="row"><pre>     the UIKit extensions to NSString. The text is drawn center of the<span></span></pre></td></tr><tr><td scope="row"><pre>     view twice - first slightly offset in black, then in white -- to give<span></span></pre></td></tr><tr><td scope="row"><pre>     an embossed appearance. The size of the font and text are calculated<span></span></pre></td></tr><tr><td scope="row"><pre>     in setupNextDisplayString.<span></span></pre></td></tr><tr><td scope="row"><pre>     */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Find point at which to draw the string so it will be in the center of the view<span></span></pre></td></tr><tr><td scope="row"><pre>    CGFloat x = self.bounds.size.width/2 - textSize.width/2;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGFloat y = self.bounds.size.height/2 - textSize.height/2;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGPoint point;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the font of the appropriate size<span></span></pre></td></tr><tr><td scope="row"><pre>    UIFont *font = [UIFont systemFontOfSize:fontSize];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [[UIColor blackColor] set];<span></span></pre></td></tr><tr><td scope="row"><pre>    point = CGPointMake(x, y + 0.5);<span></span></pre></td></tr><tr><td scope="row"><pre>    [currentDisplayString drawAtPoint:point<span></span></pre></td></tr><tr><td scope="row"><pre>                forWidth:(self.bounds.size.width-STRING_INDENT)<span></span></pre></td></tr><tr><td scope="row"><pre>                withFont:font<span></span></pre></td></tr><tr><td scope="row"><pre>                fontSize:fontSize<span></span></pre></td></tr><tr><td scope="row"><pre>                lineBreakMode:UILineBreakModeMiddleTruncation<span></span></pre></td></tr><tr><td scope="row"><pre>                baselineAdjustment:UIBaselineAdjustmentAlignBaselines];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [[UIColor whiteColor] set];<span></span></pre></td></tr><tr><td scope="row"><pre>    point = CGPointMake(x, y);<span></span></pre></td></tr><tr><td scope="row"><pre>    [currentDisplayString drawAtPoint:point<span></span></pre></td></tr><tr><td scope="row"><pre>                forWidth:(self.bounds.size.width-STRING_INDENT)<span></span></pre></td></tr><tr><td scope="row"><pre>                withFont:font<span></span></pre></td></tr><tr><td scope="row"><pre>                fontSize:fontSize<span></span></pre></td></tr><tr><td scope="row"><pre>                lineBreakMode:UILineBreakModeMiddleTruncation<span></span></pre></td></tr><tr><td scope="row"><pre>                baselineAdjustment:UIBaselineAdjustmentAlignBaselines];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When you need to draw content that is more complex than images and strings, you can use Quartz or OpenGL ES. Quartz works with UIKit to handle the drawing of vector-based paths, images, gradients, PDF, and other complex content that you want to create dynamically. Because Quartz and UIKit are based on the same drawing environment, you can call Quartz functions directly from the <code>drawRect:</code> method of your view and even mix and match Quartz calls through the use of UIKit classes. </p><p>OpenGL ES is an alternative to Quartz and UIKit that lets you render 2D and 3D content using a set of functions that resemble (but are not exactly like) those found in OpenGL for Mac OS X. Unlike Quartz and UIKit, you do not use your view’s <code>drawRect:</code> method to do your drawing. You still use a view, but you use that view object primarily to provide the drawing surface for your OpenGL ES code. How often you update the drawing surface, and which objects you use to do so, are your decision. </p><p>For detailed information about each of the drawing technologies and how you use them, see <span class="content_text"><!--a target="_self" -->“Supporting High-Resolution Screens”<!--/a--></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW30" title="Handling Touch Events"></a><h3>Handling Touch Events</h3><p>The Multi-Touch interface in iOS makes it possible for your application to recognize and respond to distinct events generated by multiple fingers touching the device. The ability to respond to multiple fingers offers considerable power but represents a significant departure from the way traditional, mouse-based event-handling systems operate. As each finger touches the surface of the device, the touch sensor generates a new touch event. As each finger moves, additional touch events are generated to indicate the finger’s new position. When a finger loses contact with the device surface, the system delivers yet another touch event to indicate that fact.</p><p>Because there may be multiple fingers touching the device at one time, it is possible for you to use those events to identify complex user gestures. The system provides some help in detecting common gestures such as swipes, but you are responsible for detecting more complex gestures. When the event system generates a new touch event, it includes information about the current state of each finger that is either touching or was just removed from the surface of the device. Because each event object contains information about all active touches, you can monitor the actions of each finger with the arrival of each new event. You can then track the movements of each finger from event to event to detect gestures, which you can apply to the contents of your application. For example, if the events indicate the user is performing a pinch-close or pinch-open gesture (as shown in <span class="content_text">Figure 4</span>) and the underlying view supports magnification, you could use those events to change the current zoom level.  </p><br><a name="//apple_ref/doc/uid/TP40007595-CH1-SW12" title="Figure 4Using touch events to detect gestures"></a><figcaption><strong class="caption_number">Figure 4</strong>&nbsp;&nbsp;Using touch events to detect gestures</figcaption><img src="Art/multi-touch.jpg" alt="Using touch events to detect gestures" width="556" height="189"><br><p>The system delivers events to the application’s responder objects, which are instances of the <code>UIResponder</code> class. In an iPhone application, your application’s views form the bulk of your custom responder objects. The MoveMe application implements two view classes, but only the <code>MoveMeView</code> class actually responds to event messages. This class detects taps both inside and outside the bounds of the Welcome button by overriding the following methods of <code>UIResponder</code>: </p><div class="codesample"><table cellspacing="0" cellpadding="3" width="100%" bgcolor="#F1F5F9" style="border: 1px solid #C9D1D7;"><tr><td scope="row"><pre>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event;<span></span></pre></td></tr></table></div><p>To simplify its own event-handling behavior, the MoveMe application tracks only the first finger to touch the surface of the device. It does this with the support of the <code>UIView</code> class, which disables multi-touch events by default. For applications that do not need to track multiple fingers, this feature is a great convenience. When multi-touch events are disabled, the system delivers events only related to the first finger to touch the device. Events related to additional touches in a sequence are never delivered to the view. If you want the information for those additional touches, however, you can reenable multi-touch support using the <code>setMultipleTouchEnabled:</code> method of the <code>UIView</code> class.</p><p>As part of its event-handling behavior, the <code>MoveMeView</code> class performs the following steps:</p><ol class="ol"><li><p>When a touch first arrives, it checks to see where the event occurred.</p><ul><li><p>Double-taps outside the Welcome button update the string displayed by the button.</p></li><li><p>Single taps inside the button center the button underneath the finger and trigger an initial animation to enlarge the button.</p></li><li><p>All other touches are ignored.</p></li></ul></li><li><p>If the finger moves and is inside the button, the button’s position is updated to match the new position of the finger.</p></li><li><p>If the finger was inside the button and then lifts off the surface of the device, an animation moves the button back to its original position. </p></li></ol><p><span class="content_text">Listing 5</span> shows the <code>touchesBegan:withEvent:</code> method for the <code>MoveMeView</code> class. The system calls this method when a finger first touches the device. This method gets the set of all touches and extracts the one and only touch object from it. The information in the <code>UITouch</code> object is used to identify in which view the touch occurred (the <code>MoveMeView</code> object or the <code>PlacardView</code> object) and the number of taps associated with the touch. If the touch represents a double tap outside the button, the <code>touchesBegan:withEvent:</code> method calls the <code>setupNextDisplayString</code> method to change the welcome string of the button. If the event occurred inside the Welcome button, it uses the <code>animateFirstTouchAtPoint:</code> method to grow the button and track it to the touch location. All other touch-related events are ignored.</p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW13" title="Listing 5Handling an initial touch event"></a><p class="codesample clear"><strong class="caption_number">Listing 5</strong>&nbsp;&nbsp;Handling an initial touch event</p><div class="codesample"><table cellspacing="0" cellpadding="3" width="100%" bgcolor="#F1F5F9" style="border: 1px solid #C9D1D7;"><tr><td scope="row"><pre>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // We only support single touches, so anyObject<span></span></pre></td></tr><tr><td scope="row"><pre>    // retrieves just that touch from touches<span></span></pre></td></tr><tr><td scope="row"><pre>    UITouch *touch = [touches anyObject];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Only move the placard view if the touch was in the placard view<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([touch view] != placardView)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // In case of a double tap outside the placard view,<span></span></pre></td></tr><tr><td scope="row"><pre>        // update the placard's display string<span></span></pre></td></tr><tr><td scope="row"><pre>        if ([touch tapCount] == 2)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            [placardView setupNextDisplayString];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // Animate the first touch<span></span></pre></td></tr><tr><td scope="row"><pre>    CGPoint touchPoint = [touch locationInView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self animateFirstTouchAtPoint:touchPoint];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 6</span> shows the <code>touchesMoved:withEvent:</code> method of the <code>MoveMeView</code> class. The system calls this method after the finger has touched the device and in response to it moving from its original location. The MoveMe application tracks only those movements that occur within the Welcome button. As a result, this method checks the location of the event and uses it to adjust the center point of the <code>PlacardView</code> object. The movement of the view causes it to be redrawn at the new location automatically.</p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW14" title="Listing 6Responding to movement from a touch"></a><p class="codesample clear"><strong class="caption_number">Listing 6</strong>&nbsp;&nbsp;Responding to movement from a touch</p><div class="codesample"><table cellspacing="0" cellpadding="3" width="100%" bgcolor="#F1F5F9" style="border: 1px solid #C9D1D7;"><tr><td scope="row"><pre>- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UITouch *touch = [touches anyObject];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If the touch was in the placardView, move the placardView<span></span></pre></td></tr><tr><td scope="row"><pre>    // to its location<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([touch view] == placardView)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CGPoint location = [touch locationInView:self];<span></span></pre></td></tr><tr><td scope="row"><pre>        placardView.center = location;<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When the user’s finger finally lifts from the screen, the MoveMe application responds by triggering an animation to move the button back to its starting position in the center of the application’s window. <span class="content_text">Listing 7</span> shows the <code>touchesEnded:withEvent:</code> method that initiates the animation. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW15" title="Listing 7Releasing the Welcome button"></a><p class="codesample clear"><strong class="caption_number">Listing 7</strong>&nbsp;&nbsp;Releasing the Welcome button</p><div class="codesample"><table cellspacing="0" cellpadding="3" width="100%" bgcolor="#F1F5F9" style="border: 1px solid #C9D1D7;"><tr><td scope="row"><pre>- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    UITouch *touch = [touches anyObject];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // If the touch was in the placardView, bounce it back to the center<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([touch view] == placardView)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Disable user interaction so subsequent touches<span></span></pre></td></tr><tr><td scope="row"><pre>        // don't interfere with animation<span></span></pre></td></tr><tr><td scope="row"><pre>        self.userInteractionEnabled = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>        [self animatePlacardViewToCenter];<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>To simplify the event handling process for the application, the <code>touchesEnded:withEvent:</code> method disables touch events for the view temporarily while the button animates back to its original position. If it did not do this, each of the event-handling methods would need to include logic to determine whether the button was in the middle of an animation and, if so, cancel the animation. Disabling user interactions for the short time it takes the button to travel back to the center of the screen simplifies the event handling code and eliminates the need for the extra logic. Upon reaching its original position, the <code>animationDidStop:finished:</code> method of the <code>MoveMeView</code> class reenables user interactions so that the event cycle can begin all over again.</p><p>If the application is interrupted for some reason—for example, by an incoming phone call—the view is sent a <code>touchesCancelled:withEvent:</code> message. In this situation, the application should try to do as little work as possible to avoid competing for device resources. In the example implementation, the placard view’s center and transformation are simply set to their original values.</p><div class="codesample"><table cellspacing="0" cellpadding="3" width="100%" bgcolor="#F1F5F9" style="border: 1px solid #C9D1D7;"><tr><td scope="row"><pre>- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event {<span></span></pre></td></tr><tr><td scope="row"><pre>    placardView.center = self.center;<span></span></pre></td></tr><tr><td scope="row"><pre>    placardView.transform = CGAffineTransformIdentity;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div><p>For more information on handling events in iOS, see <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/RevisionHistory.html#//apple_ref/doc/uid/TP40007072-CH9" target="_self">“Document Revision History”</a></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>.</p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW29" title="Animating the Button’s Movement"></a><h3>Animating the Button’s Movement</h3><p>In iPhone applications, animation plays a very important role. Animation is used extensively to provide the user with contextual information and immediate feedback. For example, when the user navigates hierarchical data in a productivity application, rather than just replace one screen with another, iPhone applications animate the movement of each new screen into place. The direction of movement indicates whether the user is moving up or down in the hierarchy and also provides a visual cue that there is new information to look at.</p><p>Because of its importance, support for animation is built into the classes of UIKit already. The MoveMe application takes advantage of this support by using it to animate the different aspects of the Welcome button. When the user first touches the button, the application applies an animation that causes the size of the button to grow briefly. When the user lets go of the button, another animation snaps it back to its original position. The basic steps for creating these animations are essentially the same:</p><ol class="ol"><li><p>Call the <code>beginAnimations:context:</code> method of the view you want to animate.</p></li><li><p>Configure the animation properties.</p></li><li><p>Call the <code>commitAnimations</code> method of the view to begin the animation.</p></li></ol><p><span class="content_text">Listing 8</span> shows the animation code used to pulse the Welcome button when it is first touched. This method sets the duration of the animation and then applies a transform to the button that scales it to its new size. When this animation completes, the animation infrastructure calls the <code>growAnimationDidStop:finished:context:</code> method of the animation delegate, which completes the pulse animation by shrinking the button slightly and moving the placard view under the touch.</p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW16" title="Listing 8Animating the Welcome button"></a><p class="codesample clear"><strong class="caption_number">Listing 8</strong>&nbsp;&nbsp;Animating the Welcome button</p><div class="codesample"><table cellspacing="0" cellpadding="3" width="100%" bgcolor="#F1F5F9" style="border: 1px solid #C9D1D7;"><tr><td scope="row"><pre>- (void)animateFirstTouchAtPoint:(CGPoint)touchPoint<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#define GROW_ANIMATION_DURATION_SECONDS 0.15<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSValue *touchPointValue = [[NSValue valueWithCGPoint:touchPoint] retain];<span></span></pre></td></tr><tr><td scope="row"><pre>    [UIView beginAnimations:nil context:touchPointValue];<span></span></pre></td></tr><tr><td scope="row"><pre>    [UIView setAnimationDuration:GROW_ANIMATION_DURATION_SECONDS];<span></span></pre></td></tr><tr><td scope="row"><pre>    [UIView setAnimationDelegate:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    [UIView setAnimationDidStopSelector: @selector(growAnimationDidStop:finished:context:)];<span></span></pre></td></tr><tr><td scope="row"><pre>    CGAffineTransform transform = CGAffineTransformMakeScale(1.2, 1.2);<span></span></pre></td></tr><tr><td scope="row"><pre>    placardView.transform = transform;<span></span></pre></td></tr><tr><td scope="row"><pre>    [UIView commitAnimations];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)growAnimationDidStop:(NSString *)animationID finished:(NSNumber *)finished context:(void *)context<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    #define MOVE_ANIMATION_DURATION_SECONDS 0.15<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [UIView beginAnimations:nil context:NULL];<span></span></pre></td></tr><tr><td scope="row"><pre>    [UIView setAnimationDuration:MOVE_ANIMATION_DURATION_SECONDS];<span></span></pre></td></tr><tr><td scope="row"><pre>    placardView.transform = CGAffineTransformMakeScale(1.1, 1.1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Move the placard view under the touch<span></span></pre></td></tr><tr><td scope="row"><pre>    NSValue *touchPointValue = (NSValue *)context;<span></span></pre></td></tr><tr><td scope="row"><pre>    placardView.center = [touchPointValue CGPointValue];<span></span></pre></td></tr><tr><td scope="row"><pre>    [touchPointValue release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [UIView commitAnimations];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For more information about using the built-in view-based animations, see <span class="content_text"><!--a target="_self" -->“Animating Views”<!--/a--></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>. For more information about Core Animation, see <span class="content_text"><!--a target="_self" -->“Applying Core Animation Effects”<!--/a--></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>.</p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW5" title="Finishing the Application"></a><h3>Finishing the Application</h3><p>In the preceding sections, you saw how the MoveMe application was initialized, presented its user interface, and responded to events. In addition to those aspects of the application creation, there are also smaller details that need to be considered before building an application and loading it onto a device. One of the final pieces to put in place is your application’s information property-list (<code>Info.plist</code>) file. It is an XML file that communicates basic information about your application to the system. Xcode creates a default version of this file for you and inserts your application’s initial configuration information into it. You can extend this information, however, to provide additional details about your application that the system should know. For example, you would use this file to communicate information about your application version, any custom URL schemes it supports, its launch image, and the default visibility status and style of the system status bar.</p><p><span class="content_text">Listing 9</span> shows the contents of the <code>Info.plist</code> file for the MoveMe application. This file identifies the name of the executable, the image file to display on the user’s Home screen, and the string that identifies the application uniquely to the system. Because the MoveMe application is a full-screen application—in other words, it does not display the status bar—it also includes the <code>UIStatusBarHidden</code> key and assigns to it the value <code>true</code>. Setting this key to <code>true</code> lets the system know that it should not display the application status bar at launch time or while the application is running. Although the MoveMe application could configure this same behavior programmatically, that behavior would not take effect until after the application was already launched, which might look odd.</p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW8" title="Listing 9The contents of the Info.plist file"></a><p class="codesample clear"><strong class="caption_number">Listing 9</strong>&nbsp;&nbsp;The contents of the <code>Info.plist</code> file</p><div class="codesample"><table cellspacing="0" cellpadding="3" width="100%" bgcolor="#F1F5F9" style="border: 1px solid #C9D1D7;"><tr><td scope="row"><pre>&lt;?xml version="1.0" encoding="UTF-8"?><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"<span></span></pre></td></tr><tr><td scope="row"><pre>"http://www.apple.com/DTDs/PropertyList-1.0.dtd"><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;plist version="1.0"><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleDevelopmentRegion&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>en&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleDisplayName&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>${PRODUCT_NAME}&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleExecutable&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>${EXECUTABLE_NAME}&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleIconFile&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>Icon.png&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>com.yourcompany.${PRODUCT_NAME:identifier}&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleInfoDictionaryVersion&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>6.0&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleName&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>${PRODUCT_NAME}&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundlePackageType&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>APPL&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleSignature&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>????&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleVersion&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>1.0&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>UIStatusBarHidden&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;true/><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>NSMainNibFile&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>MainWindow&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/plist><span></span></pre></td></tr></table></div><div class="notebox"><aside><a name="//apple_ref/doc/uid/TP40007595-CH1-SW22" title="Note"></a><p><strong>Note:</strong>&nbsp;You can edit the contents of your application’s <code>Info.plist</code> file using TextEdit, which displays the XML contents of the file as shown in <span class="content_text">Listing 9</span>, or the Property List Editor, which displays the file’s keys and values in a table. Xcode also provides access to some of these attributes in the information window for your application target. To view this window, select your application target (in the Targets group) and choose File > Get Info. The Properties tab contains some (but not all) of the properties in the <code>Info.plist</code> file.</p><p></p></aside></div><p>For information about configuring your application’s <code>Info.plist</code> file, see <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BuildTimeConfiguration/BuildTimeConfiguration.html#//apple_ref/doc/uid/TP40007072-CH7-SW15" target="_self">“The Information Property List”</a></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>. </p><p>With this final piece in place, you now have all of the basic information needed to create your own functional iPhone application. The next step is to expand on the information you learned here by learning more about the features of iOS. The applications you create should take advantage of the built-in features of iOS to create a pleasant and intuitive user experience. Some of these features are described in <span class="content_text"><a href="#//apple_ref/doc/uid/TP40007595-CH1-SW37">“Taking Your Applications Further”</a></span>, but for a complete list, and for information on how to use them, see <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW37" title="Taking Your Applications Further"></a><h3>Taking Your Applications Further</h3><p>There are many features associated with iPhone and iPod touch that users take for granted. Some of these features are hardware related, such as the automatic adjustment of views in response to a change in a device’s orientation. Others are software related, such as the fact that the built-in iPhone applications all share a single list of contacts. Because so many of the features described next are integral to the basic user experience, you should consider them during your initial design to see how they might fit into your application.  </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW31" title="Tracking Orientation and Motion Using the Accelerometers"></a><h4>Tracking Orientation and Motion Using the Accelerometers</h4><p>The accelerometers in iPhone and iPod touch provide valuable input for the system and for your own custom applications. An accelerometer measures changes in velocity along a single linear axis. Both iPhone and iPod touch have three accelerometers to measure changes along each of the primary axes in three-dimensional space, allowing you to detect motion in any direction. </p><br><a name="//apple_ref/doc/uid/TP40007595-CH1-SW38" title="Figure 5Accelerometer axes"></a><figcaption><strong class="caption_number">Figure 5</strong>&nbsp;&nbsp;Accelerometer axes</figcaption><img src="Art/device_axes.jpg" alt="Accelerometer axes" width="367" height="389"><br><p>Although you might not think measuring changes in acceleration would be very useful, in reality there is a lot you can do with the information. The force of gravity is constantly trying to pull objects to the ground. This force results in a measurable amount of acceleration toward the ground even when the device is at rest. By tracking which accelerometers are registering this acceleration, and the extent of that acceleration, you can detect the physical orientation of a device in 3D space with a fair amount of accuracy. You can then apply this orientation as input to your application. </p><p>The system uses the accelerometers to monitor a device’s current orientation and to notify your application when that orientation changes. If your application’s interface can be displayed in both landscape and portrait mode, you should incorporate view controllers into your basic design. The <code>UIViewController</code> class provides the infrastructure needed to rotate your interface and adjust the position of views automatically in response to orientation changes. </p><p>If you want access to the raw accelerometer data directly, you can do so using the shared <code>UIAccelerometer</code> object in UIKit. The <code>UIAccelerometer</code> object reports the current accelerometer values at a configurable interval. You can also use the data to detect the device’s orientation or to detect other types of instantaneous motion, such as the user shaking the device back and forth. You can then use this information as input to a game or other application. For examples of how to configure the <code>UIAccelerometer</code> object and receive accelerometer events, see <span class="content_text"><!--a target="_self" -->“Accessing Accelerometer Events”<!--/a--></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW34" title="Accessing the User’s Contacts"></a><h4>Accessing the User’s Contacts</h4><p>The user’s list of contacts is an important resource that all system applications share. The Phone, Mail, and SMS Text applications use it to identify people the user needs to contact and to facilitate basic interactions such as starting a phone call, email, or text message. Your own applications can access this list of contacts for similar purposes or to get other information relevant to your application’s needs. </p><br><a name="//apple_ref/doc/uid/TP40007595-CH1-SW23" title="Figure 6Accessing the user’s contacts"></a><figcaption><strong class="caption_number">Figure 6</strong>&nbsp;&nbsp;Accessing the user’s contacts</figcaption><img src="Art/contact_photo.jpg" alt="Accessing the user’s contacts" width="166" height="312"><br><p>iOS provides both direct access to the user’s contacts and indirect access through a set of standard picker interfaces. Using direct access, you can obtain the contact information directly from the contacts database. You might use this information in cases where you want to present contact information in a different way or filter it based on application-specific criteria. In cases where you do not need custom interface, however, iOS also provides the set of standard system interfaces for picking and creating contacts. Incorporating these interfaces into your applications requires little effort but makes your application look and feel like it’s part of the system.</p><p>You access the user’s contact information using the Address Book and Address Book UI frameworks. For more information about these frameworks, see <span class="content_text"><a href="../../../documentation/AddressBook/Reference/AddressBook_iPhoneOS_Framework/_index.html#//apple_ref/doc/uid/TP40007212" target="_self">Address Book Framework Reference for iOS</a></span> and <span class="content_text"><a href="../../../documentation/AddressBookUI/Reference/AddressBookUI_Framework/_index.html#//apple_ref/doc/uid/TP40007082" target="_self">Address Book UI Framework Reference for iOS</a></span>.</p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW32" title="Getting the User’s Current Location"></a><h4>Getting the User’s Current Location</h4><p>Devices that run iOS are meant for users on the go. Therefore the software you write for these devices should also take this fact into account. And because the Internet and web make it possible to do business anywhere, being able to tailor information for the user’s current location can make for a compelling user experience. After all, why list coffee shops in New York for someone who is thirsty and currently in Los Angeles? That’s where the Core Location framework can help.</p><p>The Core Location framework monitors signals coming from cell phone towers and Wi-Fi hotspots and uses them to triangulate the user’s current position. You can use this framework to grab an initial location fix only, or you can be notified whenever the user’s location changes. With this information, you can filter the information your application provides or use it in other ways.</p><p>For an example of how to get location data in your application, see <span class="content_text"><!--a target="_self" -->“Getting the User’s Current Location”<!--/a--></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>. </p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW18" title="Playing Audio and Video"></a><h4>Playing Audio and Video</h4><p>iOS supports audio features in your application through the Core Audio and OpenAL frameworks, and provides video playback support using the Media Player framework. Core Audio provides an advanced interface for playing, recording, and manipulating sound and for parsing streamed audio. You can use it to play back simple sound effects or multichannel audio, mix sounds and position them in an audio field, and even trigger the vibrate feature of an iPhone. If you are a game developer and already have code that takes advantage of OpenAL, you can use your code in iOS to position and play back audio in your games.</p><p>The Media Player framework is what you use to play back full-screen video files. This framework supports the playback of many standard movie file formats and gives you control over the playback environment, including whether to display user controls and how to configure the aspect ratio of video content. Game developers might use this framework to play cut scenes or other prerendered content, while media-based applications can also use this framework to play back movie files.  </p><br><a name="//apple_ref/doc/uid/TP40007595-CH1-SW19" title="Figure 7Playing back custom video"></a><figcaption><strong class="caption_number">Figure 7</strong>&nbsp;&nbsp;Playing back custom video</figcaption><img src="Art/video.jpg" alt="Playing back custom video" width="312" height="166"><br><p>For information about the media technologies in iOS, see <span class="content_text"><a href="../../../documentation/AudioVideo/Conceptual/MultimediaPG/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009767" target="_self">Multimedia Programming Guide</a></span>.</p><a name="//apple_ref/doc/uid/TP40007595-CH1-SW35" title="Taking Pictures with the Built-in Camera"></a><h4>Taking Pictures with the Built-in Camera</h4><p>The Camera application on iPhone lets users take pictures and store them in a centralized photo library, along with the other pictures they upload from their computer. And although the iPod touch has no camera, it does have a photo library to hold the user’s uploaded pictures. iOS provides access to both of these features through the <code>UIImagePickerController</code> class in the UIKit framework. </p><br><a name="//apple_ref/doc/uid/TP40007595-CH1-SW28" title="Figure 8The iPhone camera"></a><figcaption><strong class="caption_number">Figure 8</strong>&nbsp;&nbsp;The iPhone camera</figcaption><img src="Art/iPhoneBack.jpg" alt="Taking pictures with the camera" width="155" height="290"><br><p>The <code>UIImagePickerController</code> class provides the implementation for both the camera and photo library interfaces for your application. These are the standard system interfaces used by other applications, including the Camera and Photos applications. When you display the picker interface, the picker controller takes care of all of the required user interactions and returns the resulting image to your application. </p><p>For information on how to use the picker interfaces, see <span class="content_text"><!--a target="_self" -->“Taking Pictures with the Camera”<!--/a--></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072">iOS Application Programming Guide</a></span> and <span class="content_text"><!--a target="_self" -->“Picking a Photo from the Photo Library”<!--/a--></span> in <span class="content_text"><a href="../../../documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_self">iOS Application Programming Guide</a></span>. </p>
        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> &#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;Last updated: 2009-10-12&#041;</p></div></div>

        <div id="feedbackForm" class="hideOnPrint" style="margin-left: auto; margin-right: auto; width: 38em; margin-bottom: 15px; margin-top: 15px; font-weight: bold; color: #333333; background: #d9d9d9; padding: 5px 10px 5px 10px; height: 15px; text-align: center; -webkit-border-radius: 12px; -moz-border-radius: 12px; vertical-align: middle;">
    Did this document help you?
    <span class="tooltip" data-abstract="<b>Yes:</b> Tell us what works for you.">
       <a href="http://developer.apple.com/feedback/?v=1&url=%2Flibrary%2Fios%2Freferencelibrary%2FGettingStarted%2FCreating_an_iPhone_App%2F_index.html%3Fdocset%3Dcom.apple.adc.documentation.AppleiOS4_3.iOSLibrary-38.54%26id%3DTP40007595-2.1&media=xcode" class='urlLink'>Yes</a>
    </span>
    <span class="tooltip" data-abstract="<b>It's good, but:</b> Report typos, inaccuracies, and so forth.">
        <a href="http://developer.apple.com/feedback/?v=2&url=%2Flibrary%2Fios%2Freferencelibrary%2FGettingStarted%2FCreating_an_iPhone_App%2F_index.html%3Fdocset%3Dcom.apple.adc.documentation.AppleiOS4_3.iOSLibrary-38.54%26id%3DTP40007595-2.1&media=xcode" class='urlLink'>It's good, but...</a>
    </span>
    <span class="tooltip" data-abstract="<b>Not helpful:</b> Tell us what would have helped.">
        <a href="http://developer.apple.com/feedback/?v=3&url=%2Flibrary%2Fios%2Freferencelibrary%2FGettingStarted%2FCreating_an_iPhone_App%2F_index.html%3Fdocset%3Dcom.apple.adc.documentation.AppleiOS4_3.iOSLibrary-38.54%26id%3DTP40007595-2.1&media=xcode" class='urlLink'>Not helpful...</a>
    </span>
</div>
        
        <!-- /CONTENTS -->
    </article>
</body>
<script charset="utf-8" src="../../../Resources/565/JavaScript/lib/prototype.js"></script>
<!-- Media player includes -->
<script charset="utf-8" src="../../../Resources/565/JavaScript/lib/scriptaculous.js"></script>
<script charset="utf-8" src="../../../Resources/565/JavaScript/lib/event_mixins.js"></script>
<script charset="utf-8" src="../../../Resources/565/JavaScript/lib/browserdetect.js"></script>
<script charset="utf-8" src="../../../Resources/565/JavaScript/lib/ac_media.js"></script>
<!-- /Media player includes -->
<script charset="utf-8" src="../../../Resources/565/JavaScript/devpubs.js"></script>
<script charset="utf-8" src="../../../Resources/565/JavaScript/book.js"></script>
<script charset="utf-8" src="../../../Resources/565/JavaScript/tasks.js"></script>
</html>